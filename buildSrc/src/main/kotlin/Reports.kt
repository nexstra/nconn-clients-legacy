import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializationConfig
import com.fasterxml.jackson.databind.SerializationFeature
import com.fasterxml.jackson.databind.node.ObjectNode
import com.fasterxml.jackson.module.kotlin.convertValue
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import com.fasterxml.jackson.module.kotlin.treeToValue
import nexstra.ddata.*
import java.io.*
import nexstra.services.config.*
import nexstra.services.toJson
import nexstra.generated.*
import org.gradle.api.GradleException
import org.gradle.api.tasks.StopActionException
import org.gradle.api.tasks.StopExecutionException
import org.gradle.api.tasks.TaskExecutionException
import org.gradle.internal.impldep.com.google.gson.JsonObject
import java.sql.ResultSet
import java.util.*
import com.fasterxml.jackson.module.kotlin.*
import nexstra.ddata.DRef
import nexstra.ddata.DataSources
import nexstra.ddata.DataSource.*


val mapper = objectMapper.configure( SerializationFeature.INDENT_OUTPUT ,true )

inline fun <reified BEAN> ResultSet.asBean() : BEAN = mapper.convertValue<BEAN>( asJsonObject() )


fun extractReports( outdir: java.io.File , _datasource: String  ){
  outdir.mkdirs()
  val datasource = DRef.fromRef<DataSource>(_datasource.removePrefix("@"))
  val jdbc = source( datasource )
  val reportMap = mutableMapOf<String,Map<String,Any>>()
  jdbc.withConnection {
    val all = query( "SELECT * from reports WHERE report_type = 'SQL'" ).toList<JsonNode> { asJsonNode() }

  for( n in all ) {
    val report : reports = configure { from ( n ) }
    println(report.name)
    val fname = report.name.replace("[^a-zA-Z_0-9-]".toRegex(), "_")
    val metaname = "${fname}.report"
    val ext = report.report_type.name.toLowerCase()

    val queryFile = "${fname}.${ext}"

    println( report.sql_query )
    val parsed = NamedParameters.parse(report.sql_query)
    println(parsed.pretty())

//    File( outdir,queryFile).writeText( parsed.reparse() )
    /*
      * Attempt to parse query on its data source
     */


    var allp = query("SELECT * from reports_input WHERE report_id = ?",report.report_id).toList { asBean<reports_input>() }.sortedBy { it.col }.toMutableList()


    if( parsed.orderedParameters.size != allp.size ) {
      println(
          "Mismatch between declared parameters and detected parameters in ${report.name}\nDetected: ${parsed.orderedParameters} ${allp}\n${report.sql_query} ")
      while (allp.size < parsed.orderedParameters.size)
        allp.add(reports_input().apply {
          col = allp.size + 1L
          name = parsed.orderedParameters[allp.size]
          description = "autogenerated"
          type = reports_input.typeEnum.STRING
        })
     while( allp.size > parsed.orderedParameters.size ) {
      println("Dropping extraneous import column ${allp[allp.size-1]}")
      allp.removeAt(allp.size-1)
     }

      //     println( StopActionException("Mismatch between declared parameters and detected parameters in ${report.name}\nDetected: ${parsed.orderedParameters} ${allp}\n${report.sql_query} ").pretty())
    }
    allp.forEachIndexed  { i , a ->

      if( a.col.toInt() != i+1 ) {
        println(
            "Mismatch between declared parameters and detected parameters in ${report.name}\nInput column mismatch: ${a.col} expected ${i + 1}")
      }
      parsed.orderedParameters [i] = a.name
    }
    File( outdir,queryFile).writeText( parsed.reparse() )


    val meta = mapOf(
        "name" to report.name,
        "type" to "report",
        "description" to report.description,
        "report_type" to report.report_type.name.toLowerCase() ,
        "dbname" to report.dbname ,
        "query" to queryFile ,
        "datasource" to  datasource ,
        "parameters" to allp.map { mapper.convertValue<Map<String,String>>( it ) - listOf("report_input_id","report_id","fillin" ) }

        )
    reportMap[metaname] = meta
    File( outdir,"${metaname}").writeText( mapper.writeValueAsString(meta) )


  }

  val connReports = query("SELECT * from connectors WHERE name like '%report%'").toList<connectors>{  asBean() }
  val typeMap = query("SELECT connector_type_id , name FROM connector_types").toList {  getInt(1) to getString(2) }.toMap()
    val clientMap = query("SELECT * from client").toList<client>{ asBean() }.map{ it.client_id to it }.toMap()
    val partnerMap = query("SELECT partner_id, code from partners").toList { getInt(1) to getString(2) }.toMap()
println( mapper.writeValueAsString(clientMap ) )
    println( mapper.writeValueAsString(partnerMap ) )


    for( c : connectors in connReports) {
     val props = propertyMapper.readTree( c.properties.byteInputStream())
     val meta =  mapper.valueToTree(c) as ObjectNode
     println("client: ${c.client_id}, ${clientMap[c.client_id]?.name} ")
     val client =clientMap[ c.client_id]

      meta["properties"] = props
     meta.remove("log_data")
     meta.remove("connector_id")
     meta["connector_type"] = nodeFactory.textNode( typeMap[ c.connector_type_id ] )
     meta.remove("connector_type_id")
     meta["client" ] = nodeFactory.textNode(client ?.let {  partnerMap[ it.partner_id] + " / " + it.name  } ?: c.client_id.toString())
     meta.remove("state")
     meta.remove("running")
      val metaname = "${c.name}.rpt"
      meta.remove("client_id")


      File( outdir,"${metaname}").writeText( mapper.writeValueAsString(meta) )


    }








  }
}

/*
   val params = jdbc.withConnection {
       query("SELECT * from parameters WHERE template_id = ?", template.template_id).toList<JsonNode> { asJsonNode() }
     }

 */

/*
  db.run {
       fetchItems<Template>(listOf(),0).forEach {
             val  template = it as Template
            println("""${template.name} = ${template.description}""")
            val name = template.name.replace("[^a-zA-Z_0-9-]".toRegex(), "_")
            val ext = template.template_type.toLowerCase()



        File(outdir, "${name}.${ext}").writeText(template.body)

      }
    }
    */
